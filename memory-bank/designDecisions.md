# 设计决策

## 架构决策

### 1. 微服务架构采用

**决策**: 采用微服务架构，将系统拆分为多个独立服务。

**背景**: 项目需要支持用户权限管理、材料管理和DevOps等多个功能模块，且预期未来会不断扩展。

**考虑的选项**:
- 单体应用架构
- 微服务架构
- 服务化单体应用

**决策理由**:
- 每个服务可以独立开发、部署和扩展
- 各团队可以选择最适合各自业务的技术栈
- 故障隔离，单个服务故障不会影响整个系统
- 更好的可伸缩性，可以针对不同服务进行独立扩展

**取舍**:
- 增加了系统复杂性
- 需要解决服务间通信和数据一致性问题
- 运维成本上升

### 2. Monorepo管理策略

**决策**: 使用pnpm Workspace和Turborepo管理多个包和应用。

**背景**: 多个微服务和客户端应用需要统一管理，同时希望共享部分代码。

**考虑的选项**:
- 多仓库(Multirepo)管理
- 单仓库(Monorepo)管理
- 混合方式

**决策理由**:
- 简化依赖管理，避免版本冲突
- 便于代码共享和重用
- 统一构建流程，提高开发效率
- 方便进行跨服务的变更

**取舍**:
- 仓库体积增大，可能影响克隆和构建速度
- 权限管理较为复杂
- 需要建立清晰的模块边界以避免紧耦合

### 3. 数据存储策略

**决策**: 同时使用MySQL和MongoDB，不同数据类型使用不同的存储方案。

**背景**: 系统同时需要处理结构化的关系型数据和非结构化的文档型数据。

**考虑的选项**:
- 全部使用关系型数据库
- 全部使用文档型数据库
- 混合使用不同类型数据库

**决策理由**:
- 关系型数据适合用户、角色、权限等结构稳定的数据
- 文档型数据库适合材料内容等结构灵活、无固定模式的数据
- 不同类型的数据使用最适合其特性的存储方案

**取舍**:
- 增加了系统复杂性
- 需要处理多数据库事务和一致性问题
- 开发团队需要掌握多种数据库技术

## 技术栈决策

### 1. 后端框架选择

**决策**: 采用NestJS作为后端框架。

**背景**: 需要一个成熟、可扩展的Node.js后端框架来构建微服务。

**考虑的选项**:
- Express
- NestJS
- Koa
- Fastify

**决策理由**:
- NestJS提供了清晰的模块化架构
- 内置依赖注入系统，便于测试和解耦
- TypeScript优先，提供良好的类型支持
- 提供了与微服务架构的良好集成
- 活跃的社区和完善的文档

**取舍**:
- 学习曲线较陡
- 比轻量级框架如Express有更多的抽象层
- 启动时间和内存占用较高

### 2. 前端框架选择

**决策**: 采用React + Ant Design构建前端应用。

**背景**: 需要构建功能丰富、交互复杂的Web应用程序。

**考虑的选项**:
- React
- Vue
- Angular
- Svelte

**决策理由**:
- React生态系统丰富
- Ant Design提供了大量现成的企业级组件
- TypeScript集成良好
- 组件化开发方式适合大型应用
- 团队已有React经验

**取舍**:
- 与Vue相比，学习曲线略陡
- JSX语法可能需要一定适应
- 状态管理需要额外库的支持

### 3. ORM选择

**决策**: 使用TypeORM作为关系型数据库ORM，Mongoose作为MongoDB ODM。

**背景**: 需要高效地操作MySQL和MongoDB数据库。

**考虑的选项**:
- TypeORM vs Sequelize vs Prisma
- Mongoose vs MongoDB原生驱动

**决策理由**:
- TypeORM与NestJS集成良好
- TypeORM提供了良好的TypeScript支持
- 数据库迁移工具内置
- Mongoose提供了丰富的模型验证功能
- 两者都有成熟的社区和文档

**取舍**:
- TypeORM比Prisma的类型安全性略低
- 需要适应两种不同的数据库访问范式

## 安全决策

### 1. 认证策略

**决策**: 使用JWT + GitHub OAuth进行认证。

**背景**: 需要安全、灵活的用户认证机制，同时支持第三方登录。

**考虑的选项**:
- Session认证
- JWT认证
- OAuth认证
- 多因素认证

**决策理由**:
- JWT适合分布式系统，无状态
- GitHub OAuth降低了用户注册门槛
- 可以灵活扩展支持其他第三方登录
- NestJS有良好的JWT和Passport集成

**取舍**:
- JWT吊销相对复杂
- 需要妥善保管密钥
- 依赖第三方服务(GitHub)的可用性

### 2. 权限管理模型

**决策**: 实现RBAC(基于角色的访问控制)模型。

**背景**: 需要灵活、可扩展的权限控制系统，适应不同用户类型和功能访问权限。

**考虑的选项**:
- 基于角色的访问控制(RBAC)
- 访问控制列表(ACL)
- 基于属性的访问控制(ABAC)

**决策理由**:
- RBAC模型易于理解和实现
- 适合企业级应用的权限管理需求
- 可以灵活定义角色和权限
- 降低了权限管理的复杂度

**取舍**:
- 比ABAC的灵活性略低
- 大量角色可能导致角色爆炸问题
- 需要额外的中间表来关联用户-角色-权限

## 接口设计决策

### 1. API风格

**决策**: 采用RESTful API设计风格。

**背景**: 需要设计清晰、一致的API接口，方便前后端交互。

**考虑的选项**:
- RESTful API
- GraphQL
- RPC

**决策理由**:
- RESTful风格成熟，设计原则清晰
- 利用HTTP方法语义简化API设计
- 与NestJS控制器模式匹配良好
- 缓存机制可以利用标准HTTP缓存

**取舍**:
- 多次请求问题(N+1问题)
- 缺乏类型校验(相比GraphQL)
- 可能存在过度获取或获取不足问题

### 2. API文档

**决策**: 使用Swagger/OpenAPI自动生成API文档。

**背景**: 需要清晰、随代码更新的API文档，方便前端开发和第三方集成。

**考虑的选项**:
- 手动维护文档
- Swagger/OpenAPI
- API Blueprint

**决策理由**:
- NestJS内置Swagger支持
- 文档与代码同步更新
- 提供交互式API测试界面
- 支持导出多种格式

**取舍**:
- 需要在代码中添加装饰器
- 增加了一定的代码冗余
- 自动生成的文档可能不如手写文档详细

## 部署决策

### 1. 容器化策略

**决策**: 使用Docker容器化所有服务。

**背景**: 需要统一的部署方式，确保开发和生产环境一致性。

**考虑的选项**:
- 直接部署到服务器
- 容器化部署
- Serverless部署

**决策理由**:
- 环境一致性，避免"在我机器上能运行"问题
- 隔离应用依赖
- 便于横向扩展
- 简化部署流程

**取舍**:
- 增加了一定的资源开销
- 需要容器化知识
- 需要容器编排解决方案

### 2. 容器编排

**决策**: 使用Docker Compose进行容器编排。

**背景**: 需要管理多个相互依赖的服务容器。

**考虑的选项**:
- Docker Compose
- Kubernetes
- AWS ECS

**决策理由**:
- Docker Compose配置简单，学习成本低
- 适合中小规模应用
- 开发和生产环境配置一致性
- 良好的本地开发体验

**取舍**:
- 缺乏高级编排功能(如自动扩缩容)
- 高可用性支持有限
- 生产环境可能需要更换为K8s等方案

## 开发工具链决策

### 1. 包管理器选择

**决策**: 使用pnpm作为包管理器。

**背景**: 需要高效管理Monorepo项目中的多个包和依赖。

**考虑的选项**:
- npm
- Yarn
- pnpm

**决策理由**:
- pnpm使用硬链接和符号链接共享依赖，节省磁盘空间
- 严格的依赖管理，避免幽灵依赖问题
- 内置对Monorepo的支持(Workspace)
- 安装速度快于npm和Yarn
- 与Turborepo兼容性良好

**取舍**:
- 相比npm和Yarn，社区支持略少
- 某些工具可能不完全兼容pnpm
- 学习曲线略高于npm

### 2. 构建工具选择

**决策**: 使用Turborepo进行构建优化和任务编排。

**背景**: Monorepo项目需要高效的构建系统，能够处理多个包和应用的构建依赖关系。

**考虑的选项**:
- Lerna
- Nx
- Turborepo
- 自定义脚本

**决策理由**:
- 远程缓存功能大幅提高构建速度
- 任务依赖图能够并行执行无依赖任务
- 配置简单，学习曲线低
- 与pnpm集成良好
- 轻量级，不需要插件系统

**取舍**:
- 功能比Nx少
- 较新的工具，某些高级功能还在开发中
- 需要设置缓存服务器以充分利用远程缓存

### 3. 代码规范工具

**决策**: 使用ESLint + Prettier + TypeScript管理代码质量和风格。

**背景**: 多人协作项目需要统一的代码规范和类型检查。

**考虑的选项**:
- ESLint vs TSLint
- Prettier vs 自定义格式化规则
- TypeScript vs JavaScript

**决策理由**:
- ESLint提供可扩展的代码质量检查
- Prettier确保一致的代码格式，减少格式相关争议
- TypeScript提供静态类型检查，减少运行时错误
- 三者结合提供全面的代码质量保障
- NestJS默认支持TypeScript

**取舍**:
- 初始配置工作较多
- 构建时间增加
- 新成员需要学习TypeScript

## 未来扩展性考虑

### 1. 微服务扩展策略

**计划**: 设计可扩展的微服务架构，可以方便地添加新服务。

**实现手段**:
- 抽象共享库以避免代码重复
- 自动化服务注册和发现
- 设计清晰的服务间通信协议
- 标准化API设计以保持一致性

### 2. 国际化支持

**计划**: 设计支持多语言的系统架构。

**实现手段**:
- 使用i18n库处理翻译
- 所有用户界面文本使用翻译键
- 后端API错误消息支持翻译
- 数据模型设计考虑多语言内容

## 持续集成与部署管道决策

### 1. CI/CD平台选择

**决策**: 使用GitHub Actions作为CI/CD平台。

**背景**: 需要实现持续集成和持续部署，确保代码质量和自动化部署。

**考虑的选项**:
- Jenkins
- Travis CI
- CircleCI
- GitHub Actions

**决策理由**:
- 与GitHub代码仓库无缝集成
- 易于配置和维护
- 支持矩阵构建，可以测试多种环境
- 社区提供大量预制Actions
- 免费计划对开源项目足够友好

**取舍**:
- 与其他Git平台集成度较低
- 复杂工作流可能需要定制Actions
- 高级特性可能需要付费

### 2. 测试策略

**决策**: 采用多层次测试策略，包括单元测试、集成测试和端到端测试。

**背景**: 确保代码质量和系统稳定性，减少生产环境中的错误。

**考虑的选项**:
- 仅单元测试
- 单元测试+集成测试
- 全面测试策略

**决策理由**:
- 单元测试覆盖基本功能和边缘情况
- 集成测试验证服务间交互
- 端到端测试模拟真实用户行为
- 自动化测试减少手动测试工作
- 提早发现问题，降低修复成本

**取舍**:
- 编写和维护测试需要额外工作
- 完整测试套件运行时间长
- 需要模拟环境和测试数据

### 3. 部署环境管理

**决策**: 建立开发、测试、预发布和生产四级环境。

**背景**: 需要不同环境用于代码验证和逐步部署。

**考虑的选项**:
- 仅开发和生产两级环境
- 开发、测试、生产三级环境
- 完整的四级环境架构

**决策理由**:
- 开发环境用于日常开发和功能验证
- 测试环境用于QA测试和自动化测试
- 预发布环境与生产环境配置相同，用于最终验证
- 生产环境仅部署经过充分测试的版本
- 多级环境降低生产环境风险

**取舍**:
- 维护多个环境增加了运维成本
- 相同架构的多环境需要更多资源
- 需要自动化环境配置以减少管理负担

### 4. 部署策略

**决策**: 采用蓝绿部署策略，结合金丝雀发布进行风险控制。

**背景**: 需要安全可靠的部署方式，减少用户影响并能够快速回滚。

**考虑的选项**:
- 直接部署
- 滚动更新
- 蓝绿部署
- 金丝雀发布

**决策理由**:
- 蓝绿部署提供即时切换和回滚能力
- 新旧版本并存，减少部署风险
- 金丝雀发布允许小比例用户测试
- 问题出现时影响范围可控
- 切换过程对用户透明

**取舍**:
- 需要额外的基础设施资源
- 配置和管理较为复杂
- 需要自动化脚本支持 